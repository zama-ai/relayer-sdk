import type {
  DecryptedFheValueMap,
  EncryptionBits,
  FheTypeEncryptionBitwidthToIdMap,
  FheTypeId,
  FheTypeIdToEncryptionBitwidthMap,
  FheTypeIdToNameMap,
  FheTypeName,
  FheTypeNameToIdMap,
  SolidityPrimitiveTypeName,
  TypeNameToFheTypeNameMap,
} from './types/public-api';
import type { ErrorMetadataParams } from '@base/errors/ErrorBase';
import { InvalidTypeError } from '@base/errors/InvalidTypeError';
import { assert } from '@base/errors/InternalError';
import type {
  Bytes,
  Uint128BigInt,
  Uint16Number,
  Uint256BigInt,
  Uint32Number,
  Uint64BigInt,
  Uint8Number,
} from '@base/types/primitives';
import {
  assertIsUint,
  assertIsUintBigInt,
  assertIsUintNumber,
  MAX_UINT128,
  MAX_UINT16,
  MAX_UINT256,
  MAX_UINT32,
  MAX_UINT64,
  MAX_UINT8,
  MAX_UINT_FOR_TYPE,
} from '@base/uint';
import { bigIntToBytesHex, bytesToBigInt } from '@base/bytes';
import {
  addressToChecksummedAddress,
  asChecksummedAddress,
  assertIsAddress,
} from '@base/address';
import { assertNever } from '@base/errors/utils';
import { asBoolean } from '@base/boolean';
import type { TypeName } from '@base/typedvalue';

////////////////////////////////////////////////////////////////////////////////

// TFHE encryption requires a minimum of 2 bits per value.
// Booleans use 2 bits despite only needing 1 bit for the value itself.
const MINIMUM_ENCRYPTION_BIT_WIDTH = 2;

////////////////////////////////////////////////////////////////////////////////
// Lookup Maps
////////////////////////////////////////////////////////////////////////////////

const FheTypeNameToId: FheTypeNameToIdMap = {
  ebool: 0,
  //euint4: 1, has been deprecated
  euint8: 2,
  euint16: 3,
  euint32: 4,
  euint64: 5,
  euint128: 6,
  eaddress: 7,
  euint256: 8,
} as const;

const FheTypeIdToName: FheTypeIdToNameMap = {
  0: 'ebool',
  //1: 'euint4', has been deprecated
  2: 'euint8',
  3: 'euint16',
  4: 'euint32',
  5: 'euint64',
  6: 'euint128',
  7: 'eaddress',
  8: 'euint256',
} as const;

const TypeNameToFheTypeName: TypeNameToFheTypeNameMap = {
  bool: 'ebool',
  uint8: 'euint8',
  uint16: 'euint16',
  uint32: 'euint32',
  uint64: 'euint64',
  uint128: 'euint128',
  uint256: 'euint256',
  address: 'eaddress',
} as const;

// TFHE encryption requires a minimum of 2 bits per value.
// Booleans use 2 bits despite only needing 1 bit for the value itself.
const FheTypeIdToEncryptionBitwidth: FheTypeIdToEncryptionBitwidthMap = {
  0: 2,
  //1:?, euint4 has been deprecated
  2: 8,
  3: 16,
  4: 32,
  5: 64,
  6: 128,
  7: 160,
  8: 256,
} as const;

const EncryptionBitwidthToFheTypeId: FheTypeEncryptionBitwidthToIdMap = {
  2: 0,
  //?:1, euint4 has been deprecated
  8: 2,
  16: 3,
  32: 4,
  64: 5,
  128: 6,
  160: 7,
  256: 8,
} as const;

const FheTypeIdToSolidityPrimitiveTypeName: Readonly<
  Record<FheTypeId, SolidityPrimitiveTypeName>
> = {
  0: 'bool',
  //1:'uint256', euint4 has been deprecated
  2: 'uint256',
  3: 'uint256',
  4: 'uint256',
  5: 'uint256',
  6: 'uint256',
  7: 'address',
  8: 'uint256',
} as const;

const FheTypeNameToMaxValue: Readonly<
  Omit<DecryptedFheValueMap, 'ebool' | 'eaddress'>
> = {
  euint8: MAX_UINT8 as Uint8Number,
  euint16: MAX_UINT16 as Uint16Number,
  euint32: MAX_UINT32 as Uint32Number,
  euint64: MAX_UINT64 as Uint64BigInt,
  euint128: MAX_UINT128 as Uint128BigInt,
  euint256: MAX_UINT256 as Uint256BigInt,
} as const;

Object.freeze(FheTypeNameToId);
Object.freeze(FheTypeIdToEncryptionBitwidth);
Object.freeze(EncryptionBitwidthToFheTypeId);
Object.freeze(FheTypeIdToSolidityPrimitiveTypeName);
Object.freeze(FheTypeNameToMaxValue);

////////////////////////////////////////////////////////////////////////////////
// Type Guards
////////////////////////////////////////////////////////////////////////////////

/**
 * Checks if a value is a valid FheTypeId.
 * @example isFheTypeId(2) // true (euint8)
 * @example isFheTypeId(1) // false (euint4 is deprecated)
 */
export function isFheTypeId(value: unknown): value is FheTypeId {
  if (typeof value !== 'number') {
    return false;
  }
  return value in FheTypeIdToName;
}

/**
 * Asserts that a value is a valid FheTypeId.
 * @throws A {@link InvalidTypeError} If value is not a valid FheTypeId.
 * @example assertIsFheTypeId(2) // passes
 * @example assertIsFheTypeId(1) // throws (deprecated)
 */
export function assertIsFheTypeId(
  value: unknown,
  options: ErrorMetadataParams & { subject?: string },
): asserts value is FheTypeId {
  if (!isFheTypeId(value)) {
    throw new InvalidTypeError(
      {
        subject: options.subject,
        expectedType: 'Custom',
        expectedCustomType: Object.keys(FheTypeIdToName).join('|'),
      },
      options,
    );
  }
}

/**
 * Try to cast a value to FheTypeId, throwing if invalid.
 * @throws A {@link InvalidTypeError} If value is not a valid FheTypeId.
 * @example const name = asFheTypeId(2) // 2 as FheTypeId
 * @example const name = asFheTypeId(1) // throws (deprecated)
 */
export function asFheTypeId(value: unknown): FheTypeId {
  assertIsFheTypeId(value, {});
  return value;
}

/**
 * Checks if a value is a valid FheTypeName.
 * @example isFheTypeName('euint8') // true
 * @example isFheTypeName('euint4') // false (deprecated)
 */
export function isFheTypeName(value: unknown): value is FheTypeName {
  if (typeof value !== 'string') {
    return false;
  }
  return value in FheTypeNameToId;
}

/**
 * Asserts that a value is a valid FheTypeName.
 * @throws A {@link InvalidTypeError} If value is not a valid FheTypeName.
 * @example assertIsFheTypeName('euint8') // passes
 * @example assertIsFheTypeName('euint4') // throws (deprecated)
 */
export function assertIsFheTypeName(
  value: unknown,
  options: ErrorMetadataParams & { subject?: string },
): asserts value is FheTypeName {
  if (!isFheTypeName(value)) {
    throw new InvalidTypeError(
      {
        subject: options.subject,
        expectedType: 'Custom',
        expectedCustomType: Object.keys(FheTypeNameToId).join('|'),
      },
      options,
    );
  }
}

/**
 * Try to cast a value to FheTypeName, throwing if invalid.
 * @throws A {@link InvalidTypeError} If value is not a valid FheTypeName.
 * @example const name = asFheTypeName('euint8') // 'euint8' as FheTypeName
 * @example const name = asFheTypeName('euint4') // throws (deprecated)
 */
export function asFheTypeName(value: unknown): FheTypeName {
  assertIsFheTypeName(value, {});
  return value;
}

/**
 * Checks if a value is a valid encryption bit width.
 * @example isEncryptionBits(8) // true
 * @example isEncryptionBits(4) // false (euint4 is deprecated)
 */
export function isEncryptionBits(value: unknown): value is EncryptionBits {
  if (typeof value !== 'number') {
    return false;
  }
  return value in EncryptionBitwidthToFheTypeId;
}

/**
 * Try to cast a value to EncryptionBits, throwing if invalid.
 * @throws A {@link InvalidTypeError} If value is not a valid encryption bit width.
 * @example const b8 = asEncryptionBits(8) // 8 as EncryptionBits
 * @example const b4 = asEncryptionBits(4) // throws (euint4 is deprecated)
 */
export function asEncryptionBits(value: unknown): EncryptionBits {
  assertIsEncryptionBits(value, {});
  return value;
}

/**
 * Asserts that a value is a valid encryption bit width.
 * @throws A {@link InvalidTypeError} If value is not a valid encryption bit width.
 * @example assertIsEncryptionBits(8) // passes
 * @example assertIsEncryptionBits(4) // throws (euint4 is deprecated)
 */
export function assertIsEncryptionBits(
  value: unknown,
  options: ErrorMetadataParams & { subject?: string },
): asserts value is EncryptionBits {
  if (!isEncryptionBits(value)) {
    throw new InvalidTypeError(
      {
        subject: options.subject,
        expectedType: 'Custom',
        expectedCustomType: Object.keys(EncryptionBitwidthToFheTypeId).join(
          '|',
        ),
      },
      options,
    );
  }
}

/**
 * Asserts that a value is a valid encryption bit width.
 * @throws A {@link InvalidTypeError} If value is not a valid encryption bit width.
 * @example assertIsEncryptionBits(8) // passes
 * @example assertIsEncryptionBits(4) // throws (euint4 is deprecated)
 */
export function assertIsEncryptionBitsArray(
  value: unknown,
  options: ErrorMetadataParams & { subject?: string },
): asserts value is EncryptionBits[] {
  if (!Array.isArray(value)) {
    throw new InvalidTypeError(
      {
        type: typeof value,
        expectedCustomType: 'EncryptionBits[]',
        expectedType: 'Custom',
      },
      options,
    );
  }
  for (let i = 0; i < value.length; ++i) {
    if (!isEncryptionBits(value[i])) {
      throw new InvalidTypeError(
        {
          subject: options.subject,
          index: i,
          type: typeof value[i],
          expectedCustomType: 'EncryptionBits',
          expectedType: 'Custom',
        },
        options,
      );
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
// FheTypeId extractors
////////////////////////////////////////////////////////////////////////////////

/**
 * Converts an encryption bit width to its corresponding FheTypeId.
 * Accepts loose `number` input; validates internally via `isEncryptionBits`.
 * @throws A {@link FheTypeError} If bitwidth is not a valid encryption bit width.
 * @example fheTypeIdFromEncryptionBits(8) // 2 (euint8)
 */
export function fheTypeIdFromEncryptionBits(
  bitwidth: EncryptionBits,
): FheTypeId {
  return EncryptionBitwidthToFheTypeId[bitwidth];
}

/**
 * Converts an FheTypeName to its corresponding FheTypeId.
 * Accepts loose `string` input; validates internally via `isFheTypeName`.
 * @throws A {@link FheTypeError} If name is not a valid FheTypeName.
 * @example fheTypeIdFromName('euint8') // 2
 */
export function fheTypeIdFromName(name: FheTypeName): FheTypeId {
  return FheTypeNameToId[name];
}

/**
 * Converts an FheTypeId to its corresponding FheTypeName.
 * @throws A {@link FheTypeError} If id is not a valid FheTypeId.
 * @example fheTypeNameFromId(2) // 'euint8'
 */
export function fheTypeNameFromId(typeId: FheTypeId): FheTypeName {
  return FheTypeIdToName[typeId];
}

/**
 * Converts a TypeName to its corresponding FheTypeName.
 * @throws A {@link FheTypeError} If id is not a valid FheTypeId.
 * @example fheTypeNameFromTypeName('uint8') // 'euint8'
 */
export function fheTypeNameFromTypeName(typeName: TypeName): FheTypeName {
  return TypeNameToFheTypeName[typeName];
}

////////////////////////////////////////////////////////////////////////////////
// Solidity primitive type names
////////////////////////////////////////////////////////////////////////////////

/**
 * Returns the Solidity primitive type name for an FheTypeId.
 * Accepts loose `number` input; validates internally via `isFheTypeId`.
 * @example solidityPrimitiveTypeNameFromFheTypeId(0) // 'bool'
 * @example solidityPrimitiveTypeNameFromFheTypeId(7) // 'address'
 * @example solidityPrimitiveTypeNameFromFheTypeId(2) // 'uint256'
 */
export function solidityPrimitiveTypeNameFromFheTypeId(
  typeId: FheTypeId,
): SolidityPrimitiveTypeName {
  return FheTypeIdToSolidityPrimitiveTypeName[typeId];
}

////////////////////////////////////////////////////////////////////////////////
// Encryption Bits
////////////////////////////////////////////////////////////////////////////////

/**
 * Returns the encryption bit width for an FheTypeId.
 * @param typeId - The FHE type Id
 * @returns The encryption bit width (always \>= 2)
 * @example encryptionBitsFromFheTypeId(2) // 8 (euint8)
 * @example encryptionBitsFromFheTypeId(7) // 160 (eaddress)
 */
export function encryptionBitsFromFheTypeId(typeId: FheTypeId): EncryptionBits {
  const bw = FheTypeIdToEncryptionBitwidth[typeId];

  // Invariant: bit width must be >= 2 (TFHE minimum encryption granularity)
  _assertMinimumEncryptionBitWidth(bw);

  return bw;
}

/**
 * Returns the encryption bit width for an FheType name.
 * @param name - The FHE type name (e.g., 'ebool', 'euint32', 'eaddress')
 * @returns The encryption bit width (always \>= 2)
 * @example encryptionBitsFromFheTypeName('ebool') // 2
 * @example encryptionBitsFromFheTypeName('euint32') // 32
 * @example encryptionBitsFromFheTypeName('eaddress') // 160
 */
export function encryptionBitsFromFheTypeName(
  name: FheTypeName,
): EncryptionBits {
  const bw = FheTypeIdToEncryptionBitwidth[FheTypeNameToId[name]];

  // Invariant: bit width must be >= 2 (TFHE minimum encryption granularity)
  _assertMinimumEncryptionBitWidth(bw);

  return bw;
}

function _assertMinimumEncryptionBitWidth(bw: number): void {
  assert(
    bw >= MINIMUM_ENCRYPTION_BIT_WIDTH,
    `Invalid FheType encryption bit width: ${bw}. Minimum encryption bit width is ${MINIMUM_ENCRYPTION_BIT_WIDTH} bits.`,
  );
}

export function bytesToFheDecryptedValue<T extends FheTypeName>(
  fheTypeName: T,
  bytes: Bytes,
): DecryptedFheValueMap[T] {
  const bn = bytesToBigInt(bytes);

  switch (fheTypeName) {
    case 'ebool':
      return (bn !== 0n) as DecryptedFheValueMap[T];
    case 'eaddress':
      return asChecksummedAddress(
        bigIntToBytesHex(bn, { byteLength: 20 }),
      ) as DecryptedFheValueMap[T];
    case 'euint8':
    case 'euint16':
    case 'euint32': {
      assertIsUintBigInt(bn, {
        max: BigInt(FheTypeNameToMaxValue[fheTypeName]),
        subject: 'value',
      });
      return Number(bn) as DecryptedFheValueMap[T];
    }
    case 'euint64':
    case 'euint128':
    case 'euint256': {
      assertIsUintBigInt(bn, {
        max: BigInt(FheTypeNameToMaxValue[fheTypeName]),
        subject: 'value',
      });
      return bn as DecryptedFheValueMap[T];
    }
    default:
      return assertNever(fheTypeName, `Unknown fheTypeName: ${fheTypeName}`);
  }
}

export function asFheDecryptedValue<T extends FheTypeName>(
  fheTypeName: T,
  value: unknown,
  options?: { subject?: string } & ErrorMetadataParams,
): DecryptedFheValueMap[T] {
  switch (fheTypeName) {
    case 'ebool':
      return asBoolean(value, options) as DecryptedFheValueMap[T];
    case 'eaddress':
      return asChecksummedAddress(value, options) as DecryptedFheValueMap[T];
    case 'euint8':
    case 'euint16':
    case 'euint32': {
      assertIsUintNumber(value, {
        ...options,
        max: MAX_UINT_FOR_TYPE[fheTypeName],
      });
      return value as DecryptedFheValueMap[T];
    }
    case 'euint64':
    case 'euint128':
    case 'euint256': {
      assertIsUintBigInt(value, {
        ...options,
        max: MAX_UINT_FOR_TYPE[fheTypeName],
      });
      return value as DecryptedFheValueMap[T];
    }
    default:
      return assertNever(fheTypeName, `Unknown fheTypeName: ${fheTypeName}`);
  }
}

export function toDecryptedFheValue<T extends FheTypeName>(
  fheTypeName: T,
  value: unknown,
  options?: { subject?: string } & ErrorMetadataParams,
): DecryptedFheValueMap[T] {
  switch (fheTypeName) {
    case 'ebool':
      return asBoolean(value, options) as DecryptedFheValueMap[T];
    case 'eaddress':
      assertIsAddress(value, options ?? {});
      return addressToChecksummedAddress(value) as DecryptedFheValueMap[T];
    case 'euint8':
    case 'euint16':
    case 'euint32': {
      assertIsUint(value, {
        ...options,
        max: MAX_UINT_FOR_TYPE[fheTypeName],
      });
      return Number(value) as DecryptedFheValueMap[T];
    }
    case 'euint64':
    case 'euint128':
    case 'euint256': {
      assertIsUint(value, {
        ...options,
        max: MAX_UINT_FOR_TYPE[fheTypeName],
      });
      return BigInt(value) as DecryptedFheValueMap[T];
    }
    default:
      return assertNever(fheTypeName, `Unknown fheTypeName: ${fheTypeName}`);
  }
}
